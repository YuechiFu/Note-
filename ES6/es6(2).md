# 变量的解构赋值
## 1.数组的解构赋值
- #### 完全解构模式
   ``` javascript
   let [a,b,c]=[1,2,3]
   console.log(a,b,c) //1,2,3
   
   let [x,[[y],z]] = [1,[[2],3]]
   console.log(x,y,z) //1,2,3
   
   let [aa,bb,cc] = [1,,3]
   console.log(aa,bb,cc)  //1 undefined 3
   
   
   let [ , , box] = [1,2,3]
   console.log(box)  //3 
   
   let [a1,a2,a3] = [1,2,3,4,5,6,7];
   console.log(a1,a2,a3) //1 2 3
   
   let [b1,b2,...b3] = [1,2,3,4,5,6,7,8]
   console.log(b1,b2,b3) //1 2 [3, 4, 5, 6, 7, 8]
   ```
- #### 不完全解构模式、
   ``` javascript
   let [a,b] = [1,2,3]
   console.log(a,b) //1 2
   
   let [x,[y],z] =[1,[2,3],4]
   console.log(x,y,z)  //1 2 4
   ```
   ###### 不论是完全还是不完全，都要保证等式 两边的结构是一致的 数组必须与数组对应，对象必须与对象对应。 
   
   
   
- #### 默认值
   ##### 一般默认值

   ``` javascript
   let [a=1,b] = [,'hello'];
   console.log(a,b) //1 "hello"
   
   let [x=1,y=2] = ['helloX']
   console.log(x,y) //helloX 2
   
   let [a1=0,a2] = [undefined , "hello world"]
   console.log(a1,a2) // 0 "hello world"
   
   let [b1=0,b2] = [null,"hello b2"]
   console.log(b1,b2) //null "hello b2"
   ```
   注：ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
   上面 b1 值是null，默认值就不会生效，因为null不严格等于undefined。
   
   ##### 表达式默认值
   如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
   ``` javascript
   function box(){
   	return "box"
   }
   
   let [a=box(),b]=[0,1]
   console.log(a,b) //0 1
   
   let [x=box(),y] = [,1]
   console.log(x,y) //box 1
   ```
   ##### 变量默认值
   变量默认值一定得在操作之前 对该变量赋值
   ``` javascript
   let [a,b] = [0,1]
   let [x=a,y=b] = [3,4]
   let [a1=a, b1=b] = [,]
   console.log(a,b)
   console.log(x,y) // 3 4
   console.log(a1,b1) // 0 1
   ```
   
## 2.对象的解构赋值
- ### 一般写法
   对象的解构与数组有一个重要的不同。
   数组的元素是按次序排列的，变量的取值由它的位置决定；
   而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

   ``` javascript 
   let {a,b} = {a:"aaa" , b:"bbb"}
   console.log(a,b) // aaa bbb 
   
   let {x,y,z} = {
   	x : "hello",
   	y : "world",
   }
   console.log(x,y,z) //hello world undefined
   ```
- ### 变量名与属性名 不一致时 的写法
   ``` javascript
      let {x:x1,y:y1}={
   	x:"box",
   	y:"boy"
   }
   console.log(x1,y1) //box boy
   console.log(x,y) // ReferenceError: x is not defined
   ```
   可以看到 此时 x,y 都是not defined，这意味着 ，对象的解构赋值 真正起作用的其实是冒号右边的部分，它才是真正的变量名
- ### 嵌套赋值

   ``` javascript
   let {a:[x,{y}]} = {a:["hello",{y:"world"}]}
   console.log(x,y) // hello world
   ```
   多层嵌套赋值
   ``` javascript
   let box = {
   	title: "michele",
   	type:{
   		t0:{
   			count:18,
   			subtype:["s1","s2"]
   		},
   		t1:"type1",
   		t2:"type2"
   	},
   }
   
   let {
   	obj,
   	obj:{title},
   	obj:{type},
   	obj:{type:{t0}},
   	obj:{type:{t0:{subtype}}},
   	obj:{type:{t0:{subtype:[s1,s2]}}}
   } = {obj:box}
   
   console.log(title);  //michele
   console.log(type) ; // {t0: {…}, t1: "type1", t2: "type2"}
   console.log(t0);// {count: 18, subtype: Array(2)}
   console.log(subtype)// ["s1", "s2"]
   console.log(s1,s2)// s1 s2
   ```
   如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。
   
   ``` javascript 
   let _tmp = {baz: 'baz'};
   _tmp.foo.bar // 报错
   ```
   
- ### 默认值
   ``` javascript
   let {x=1,y=2} = {x:3,y:undefined}
   console.log(x,y)  // 3 2
   ```
- ### 其他情况
  #####  将一个已经声明的变量用来解构赋值格外小心
   
   ######  错误的写法
   下面的 x 已经 声明 ，此时 x 外面的{} 会被识别成一个代码块，所以这样写会被报错
   ``` javascript
      let x ; 
      {x} = {x:1}  // error : Unexpected token =
   ```
   ######  正确的写法
   将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。 
   ``` javascript
   let x ; 
   ({x} = {x:1})
   console.log(x) // 1
   
   //解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。
   ({} = [true, false]);
   ({} = 'abc');
   ({} = []);
   //上面的三个表达式虽然毫无意义，但是语法是合法的，可以执行。
   ```
   ##### 数组在对象解构中的应用
   由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
   ``` javascript
   let arr = [1,3,5,7,9]
   let {0:a1 , 1:a3 , [arr.length-1]:a5} = arr ;
   console.log(a1,a3,a5)  // 1 3 9
   ```
   
- ### 字符串的解构赋值
   解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
   要注意的是 length 是 String 的一个属性。 
   ``` javascript
   let [a1,a2,a3,a4,a5] = "hello"
   console.log(a1,a2,a3,a4,a5) //h e l l o
   
   let {length} = "xyz"
   console.log(length) // 3
   
   let [{length}] = "xyz" 
   console.log(length) // 1
   ```
- ### 数值和布尔值的解构赋值 
   解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
   下面这个列子中  表达式 右边 是数字类型。 那么此时就先转成对象 Number
   然后，根据左边的 toString 查找 Number 是否有这一属性或方法。 
   如果有 则 将其赋值 给 s1 
   所以s1得到的就是 Number的原生方法 toString ，可以利用call 来调用s1
   
   ``` javascript
   let  a = 15656489
   let {toString:s1} = 123
   console.log(s1)  // ƒ toString() { [native code] }
   console.log(s1.call(a)) //  15656489
   ```
- ### 函数参数的解构赋值
   ``` javascript
   function box({x=0,y=1}={}){
   	console.log(x+y)
   }
   
   box({x:2}) //3 
   box({x:undefined,y:null}) //0
   box({}) //1
   ```
   不同的写法会造成不同的结果
   
     ``` javascript
   function move({x, y} = { x: 0, y: 0 }) {
     return [x, y];
   }
   
   move({x: 3, y: 8}); // [3, 8]
   move({x: 3}); // [3, undefined]
   move({}); // [undefined, undefined]
   move(); // [0, 0]
   ```
   上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果
   
- ### 解构赋值的作用
   交换变量的值
   ``` javascript
   let [x,y] = [1,2] ;
   [x,y] = [y,x] ;
   console.log(x,y) // 2 1
   ```
   从函数返回多个值
   ``` javascript
   // 返回一个数组
      function example() {
        return [1, 2, 3];
      }
      let [a, b, c] = example();
      
   // 返回一个对象
   function example() {
     return {
       foo: 1,
       bar: 2
     };
   }
   let { foo, bar } = example();   
   ```
   函数参数的定义
   ``` javascript
   // 参数是一组有次序的值
   function f([x, y, z]) { ... }
   f([1, 2, 3]);
   
   // 参数是一组无次序的值
   function f({x, y, z}) { ... }
   f({z: 3, y: 2, x: 1});
   ```
   提取JSON数据
   ``` javascript
   let jsonData = {
     id: 42,
     status: "OK",
     data: [867, 5309]
   };
   let { id, status, data: number } = jsonData;
   console.log(id, status, number);
   // 42, "OK", [867, 5309]
   ```
   输入模块的指定方法
   ``` javascript
   const { SourceMapConsumer, SourceNode } = require("source-map");
   ```
